package bindatafs

import (
	"bytes"
	"net/http"
	"os"
	"strings"
)

// AssetFunc is the Assets() function generated by go-bindata
type AssetFunc func(name string) ([]byte, error)

// AssetDirFunc is the AssetDir() function generated by go-bindata
type AssetDirFunc func(name string) ([]string, error)

// AssetInfoFunc is the AssetInfo() function generated by go-bindata
type AssetInfoFunc func(name string) (os.FileInfo, error)

// generatedAssets store references to all go-bindata generated functions
type generatedAssets struct {
	asset     AssetFunc
	assetDir  AssetDirFunc
	assetInfo AssetInfoFunc
}

// Open implements FileSystem
func (assets *generatedAssets) Open(name string) (f http.File, err error) {

	if name[0] == '/' {
		name = name[1:]
	}

	// test if is an unempty dir
	names, _ := assets.assetDir(name)
	if len(names) != 0 {
		f = &File{
			Reader: bytes.NewReader([]byte{}),
			assets: assets,
			name:   name,
			t:      TypeDir,
			dirPos: 0,
		}
		return
	}

	// test if is a file
	buf, err := assets.asset(name)
	if err != nil {
		if strings.HasSuffix(err.Error(), "not found") {
			err = os.ErrNotExist
		}
		return
	}
	f = &File{
		Reader: bytes.NewReader(buf),
		assets: assets,
		name:   name,
		t:      TypeFile,
		dirPos: 0,
	}
	return
}

// New returns FileSystem implementation from a given set of go-bindata
// assets
func New(assetDir AssetDirFunc, assetInfo AssetInfoFunc, asset AssetFunc) FileSystem {
	return &generatedAssets{
		asset:     asset,
		assetDir:  assetDir,
		assetInfo: assetInfo,
	}
}

// FileSystem implements http.FileSystem and can be consumbed by default
// http.FileServer()
type FileSystem interface {
	Open(name string) (http.File, error)
}
